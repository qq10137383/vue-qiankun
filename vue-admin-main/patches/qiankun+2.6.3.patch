diff --git a/node_modules/qiankun/es/loader.js b/node_modules/qiankun/es/loader.js
index e48c06f..3afeb0a 100644
--- a/node_modules/qiankun/es/loader.js
+++ b/node_modules/qiankun/es/loader.js
@@ -137,11 +137,11 @@ var rawRemoveChild = HTMLElement.prototype.removeChild;
  * @param legacyRender
  */
 
-function getRender(appInstanceId, appContent, legacyRender) {
+function getRender(appInstanceId, appContent, legacyRender, keepAlive) {
   var render = function render(_ref, phase) {
     var element = _ref.element,
-        loading = _ref.loading,
-        container = _ref.container;
+      loading = _ref.loading,
+      container = _ref.container;
 
     if (legacyRender) {
       if (process.env.NODE_ENV === 'development') {
@@ -175,6 +175,17 @@ function getRender(appInstanceId, appContent, legacyRender) {
       assertElementExist(containerElement, errorMsg);
     }
 
+    // patch 2: 配置增加keepAlive参数，设为true时应用卸载将不会销毁挂载容器，只是隐藏(display:none)
+    if (keepAlive && containerElement) {
+      if (!element) {
+        containerElement.style.display = "none"
+        return
+      }
+      if (containerElement.firstChild) {
+        containerElement.style.display = "block"
+      }
+    }
+
     if (containerElement && !containerElement.contains(element)) {
       // clear the container
       while (containerElement.firstChild) {
@@ -279,7 +290,9 @@ export function loadApp(app) {
             initialAppWrapperElement = createElement(appContent, strictStyleIsolation, scopedCSS, appInstanceId);
             initialContainer = 'container' in app ? app.container : undefined;
             legacyRender = 'render' in app ? app.render : undefined;
-            render = getRender(appInstanceId, appContent, legacyRender); // 第一次加载设置应用可见区域 dom 结构
+            // patch 1：配置增加keepAlive参数，设为true时应用卸载将不会销毁挂载容器，只是隐藏(display:none)
+            var keepAlive = configuration.keepAlive
+            render = getRender(appInstanceId, appContent, legacyRender, keepAlive); // 第一次加载设置应用可见区域 dom 结构
             // 确保每次应用加载前容器 dom 结构已经设置完毕
 
             render({
@@ -304,7 +317,7 @@ export function loadApp(app) {
 
             if (sandbox) {
               sandboxContainer = createSandboxContainer(appInstanceId, // FIXME should use a strict sandbox logic while remount, see https://github.com/umijs/qiankun/issues/518
-              initialAppWrapperGetter, scopedCSS, useLooseSandbox, excludeAssetFilter, global); // 用沙箱的代理对象作为接下来使用的全局对象
+                initialAppWrapperGetter, scopedCSS, useLooseSandbox, excludeAssetFilter, global); // 用沙箱的代理对象作为接下来使用的全局对象
 
               global = sandboxContainer.instance.proxy;
               mountSandbox = sandboxContainer.mount;
@@ -620,9 +633,11 @@ export function loadApp(app) {
                             }, 'unmounted');
                             offGlobalStateChange(appInstanceId); // for gc
 
-                            appWrapperElement = null;
-                            syncAppWrapperElement2Sandbox(appWrapperElement);
-
+                            // patch 3: keepAlive模式下不销毁挂载容器
+                            if (!configuration.keepAlive) {
+                              appWrapperElement = null;
+                              syncAppWrapperElement2Sandbox(appWrapperElement);
+                            }
                           case 4:
                           case "end":
                             return _context15.stop();
